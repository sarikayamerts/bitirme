library(readr)
CDNOW_master <- read_csv("Downloads/CDNOW_master/CDNOW_master.txt")
View(CDNOW_master)
cdnow <- read.table("Downloads/CDNOW_master/CDNOW_master.txt")
rm(CDNOW_master)
View(cdnow)
cdnow$V1 <- NULL
View(cdnow)
colnames(cdnow) <- c(“ID”, “TARIH”, “ADET”, “FIYAT”)
cdnow <- read.table("Downloads/CDNOW_master/CDNOW_master.txt")
colnames(cdnow) <- c(“ID”, “TARIH”, “ADET”, “FIYAT”)
View(cdnow)
colnames(cdnow) <- c("ID", "TARIH", "ADET", "FIYAT")
View(cdnow)
str(cdnow)
cdnow$ID <- as.factor(as.character(cdnow$ID))
cdnow$TARIH <- as.Date(as.character(cdnow$TARIH), “%Y%m%d”)
cdnow$TARIH <- as.Date(as.character(cdnow$TARIH), "%Y%m%d")
str(cdnow)
refDay <- max(cdnow$TARIH)
class(refDay)
as.numeric(refDay — cdnow$TARIH)
as.numeric(refDay-cdnow$TARIH)
library(dplyr)
rfm_recency <- cdnow %>% group_by(ID) %>% summarise(Recency = as.numeric(refDay)—as.numeric(max(TARIH)))
rfm_recency <- cdnow %>% group_by(ID) %>% summarise(Recency = as.numeric(refDay)—as.numeric(max(TARIH)))
rfm_recency <- cdnow %>% group_by(ID) %>% summarise(Recency = as.numeric(refDay)-as.numeric(max(TARIH)))
View(rfm_recency)
rfm_frequency <- cdnow %>% group_by(ID) %>% summarise(Frequency = n())
View(rfm_frequency)
rfm_monetary <- cdnow %>% group_by(ID) %>% summarise(Monetary = sum(FIYAT))
View(rfm_monetary)
cdnow$ID == 1
cdnow[cdnow$ID == 1]
cdnow[cdnow$ID == 1]
filter(cdnow, ID == 1)
filter(cdnow, ID == 951)
filter(rfm_monetary, ID == 951)
install.packages("mlr")
install.packages("XML")
install.packages("e1071")
install.packages("e1071") --host
config.log
install.packages('e1071', dependencies=TRUE)
install.packages("e1071")
install.packages("e1071")
### clears the environment
rm(list = ls())
if (grepl("mert", toString(getwd()))){
setwd("/Users/mertsarikaya/bitirme/")
}
if (grepl("Hp", toString(getwd()))) {
setwd("C:/Users/Hp/Desktop/Bitirme/bitirme")
}
library(readr)
library(graphics)
install.packages("readr")
library(data.table)
install.packages("data.table")
install.packages("verification")
install.packages("glmnet")
install.packages("TunePareto")
install.packages("anytime")
install.packages("statsDK")
library(readr)
library(graphics)
library(data.table)
library(verification)
library(verification)
library(verification)
library(data.table)
library(verification)
library(glmnet)
library(TunePareto)
library(anytime)
library(plotly)
library(stats)
### implementation of ranked probability score
# functions in this file:
# 1 - calculate_rps(home, draw, away, actual)
# 2 - calculate_rps2(over, under, actual)
source("rps.R")
### converting odd1, oddX, odd2 to 1,2,3 and viceversa
# 1 - convert(arr)
source("converter.R")
### read and prepare dataframes (not ready)
# 1 - details (matchId, bookmaker, oddtype, odd)
# 2 - matches (matchId, score, home, away, date, over_under, winner, season)
# 3 - first (matchId, bookmaker, oddtype, odd)
# 4 - last (matchId, bookmaker, oddtype, odd)
# 5 - next_matches (matchId, score, home, away, date)
source("get_dataframes.R")
### converting odds to basic and shin probabilities
# changes first and last dataframes
source("convert_odds.R")
### changing odds
#
source("changing_odds.R")
### reshaping first and last dataframes to feature extraction
# 1 - wide_first (matchId, shin*basic*bookmaker*oddtype, winner)
# 2 - wide_last (matchId, shin*basic*bookmaker*oddtype, winner)
source("reshape.R")
#wide_first <- widening(first, c("888sport", "SBOBET", "bwin", "Pinnacle", "Betclic"))
wide_last <- widening(last[,-4], bookiesToKeep)
### calculate RPS for all matches using Basic and Shin probs
# changes in first and last dataframes
source("calculate_rps.R")
### calculate average RPS for all bookmakers using Basic and Shin probs
source("bookmaker_comparison.R")
### statistical tests
# 1- basic_vs_shin(df)
# 2-
source("statistical_tests.R")
test_match_ids <- matches[week == 47][season == '2018-2019']$matchId
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[season == "2018-2019"][week == 47]$date)
train_features <- wide_last[date < min_date]
len_train = ncol(train_features)
train <- train_features[,-c(1, 48:50)]
train$winner <- factor(convert(train$winner))
train <- train[complete.cases(train)]
test_x <- test_features[,-c(1, 47:50)]
library(caret)
install.packages("caret")
library(e1071)
library(caret)
control <- trainControl(method="repeatedcv", number=3, repeats=2)
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(winner~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
rf_default <- train(winner~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
rf_default
convert_1x2 <- function(arr){
n = length(arr)
arr_copy <- copy(arr)
for (i in 1:n){
if (arr_copy[i] < 1.80) {arr_copy[i] <- "odd1"}
else if ((arr_copy[i] >= 1.80) & (arr_copy[i] <= 2.20)) {arr_copy[i] <- "oddX"}
else {arr_copy[i] <- "odd2"}
}
as.vector(arr_copy)
}
output <- predict(rf_default, test_x)
output
convert_1x2(output)
convert(output)
converter(output)
converter
convert()
convert
output
as.integer(output)
convert(as.integer(output))
test_features$winner
test_match_ids <- matches[week == 48][season == '2018-2019']$matchId
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[season == "2018-2019"][week == 47]$date)
train_features <- wide_last[date < min_date]
len_train = ncol(train_features)
train <- train_features[,-c(1, 48:50)]
train$winner <- factor(convert(train$winner))
train <- train[complete.cases(train)]
test_x <- test_features[,-c(1, 47:50)]
control <- trainControl(method="repeatedcv", number=3, repeats=2)
seed <- 7
metric <- "Accuracy"
control <- trainControl(method="repeatedcv", number=5, repeats=3)
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(winner~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
control <- trainControl(method="repeatedcv", number=10, repeats=3)
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(winner~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
print(rf_default)
output <- predict(rf_default, test_x)
convert(as.integer(output))
test_features$winner
output <- predict(rf_default, test_x, "prob")
output
test_features$winner
calculate_rps()
calculate_rps
output <- predict(rf_default, test_x)
output_prob <- predict(rf_default, test_x, "prob")
output_prob
calculate_rps(output_prob$1,output_prob$2,output_prob$3, test_features$winner)
calculate_rps(output_prob$`1`,output_prob$`2`,output_prob$`3`, test_features$winner)
test_features$win
output_prob$`1`
output_prob$winner <- test_features$winner
output_prob
output_prob <- output_prob[, RPS := calculate_rps(`1`, `2`, `3`, winner), by = 1:nrow(lastrps)]
output_prob <- output_prob[, RPS := calculate_rps(`1`, `2`, `3`, winner), by = 1:nrow(output_prob)]
output_prob
output_prob <- output_prob[, RPS := calculate_rps(1, 2, 3, winner), by = 1:nrow(output_prob)]
calculate_rps(output_prob$`1`[1], output_prob$`2`[1], output_prob$`3`[1], output_prob$winner[1])
output_prob <- output_prob[, RPS := calculate_rps(output_prob$`1`, output_prob$`2`, output_prob$`3`, winner), by = 1:nrow(output_prob)]
output_prob <- predict(rf_default, test_x, "prob")
colnames(output_prob) <- c("odd1", "oddX", "odd2")
output_prob$winner <- test_features$winner
output_prob <- output_prob[, RPS := calculate_rps(output_prob$`1`, output_prob$`2`, output_prob$`3`, winner), by = 1:nrow(output_prob)]
output_prob <- output_prob[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
output_prob
output_prob[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
output_prob <- output_prob[,calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
output_prob <- output_prob[, RPS := calculate_rps(odd1, oddX, odd2, winner)]
output_prob <- as.data.table(output_prob)[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
output_prob
mean(output_prob$RPS)
### report of model
# functions in this file:
# 1 - model_report
source("model_report.R")
myRPS <- model_report("RF 10, 3, seed 7", n, "Basic + Shin 48th Week", "", "", "", "", predict(rf_default, test_x, "prob"), testRPS)
myRPS <- model_report("RF 10, 3, seed 7", n, "Basic + Shin 48th Week", "", "", "", "", output_prob[,c(1:3)], testRPS)
output_prob
output_prob[,c(1:3)]
test_match_ids
last[matchId %in% test_match_ids]
testRPS <- lastrps[matchId %in% predictions[["predictions"]]$matchId][, .(var = mean(Shin_RPS, na.rm = TRUE)), by = c("bookmaker")]
testRPS <- lastrps[matchId %in% test_match_ids][, .(var = mean(Shin_RPS, na.rm = TRUE)), by = c("bookmaker")]
testRPS <- testRPS[order(testRPS$var),]
testRPS
ourRPS <- mean(output_prob$RPS)
x <- data.frame("***IE 492***", ourRPS)
names(x) <- names(testRPS)
testRPS <- rbind(testRPS, x)
testRPS <- testRPS[order(testRPS$var),]
testRPS
test_match_ids <- matches[week == 48 | week == 47][season == '2018-2019']$matchId
test_match_ids
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[season == "2018-2019"][week == 47]$date)
train_features <- wide_last[date < min_date]
len_train = ncol(train_features)
train <- train_features[,-c(1, 48:50)]
train$winner <- factor(convert(train$winner))
train <- train[complete.cases(train)]
test_x <- test_features[,-c(1, 47:50)]
control <- trainControl(method="repeatedcv", number=10, repeats=3)
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(winner~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
print(rf_default)
output <- predict(rf_default, test_x)
convert_1x2(output)
convert(as.integer(output))
test_features$winner
table(convert_1x2(output), test_features$winner)
output_prob <- predict(rf_default, test_x, "prob")
colnames(output_prob) <- c("odd1", "oddX", "odd2")
output_prob$winner <- test_features$winner
output_prob <- as.data.table(output_prob)[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
testRPS <- lastrps[matchId %in% test_match_ids][, .(var = mean(Shin_RPS, na.rm = TRUE)), by = c("bookmaker")]
testRPS <- testRPS[order(testRPS$var),]
ourRPS <- mean(output_prob$RPS)
x <- data.frame("***IE 492***", ourRPS)
names(x) <- names(testRPS)
testRPS <- rbind(testRPS, x)
testRPS <- testRPS[order(testRPS$var),]
testRPS
weekNumber
weekNumber = 47
seasonYear = "2018-2019"
test_match_ids <- matches[week == weekNumber][season == seasonYear]$matchId
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[matchId %in% test_match_ids]$date)
min_date
train_features <- wide_last[date < min_date]
len_train = ncol(train_features)
train_features <- wide_last[date < min_date]
len_train = ncol(train_features)
train <- train_features[,-c(1, 48:50)]
len_train = ncol(train_features)
len_train
train_features[,-c(48:50)]
train_features[,-c(len_train-2:len_train)]
train_features
train_features[,-c("matchId", "date", "week", "season")]
#requires matches, last, wide_last
train_model <- function(weekNumber, seasonYear){
test_match_ids <- matches[week == weekNumber][season == seasonYear]$matchId
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[matchId %in% test_match_ids]$date)
train_features <- wide_last[date < min_date]
train <- train_features[,-c("matchId", "date", "week", "season")]
#train$winner <- factor(convert(train$winner))
train <- train[complete.cases(train)]
test_x <- test_features[,-c("matchId", "winner", "date", "week", "season")]
control <- trainControl(method="repeatedcv", number=10, repeats=3)
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(factor(convert(winner))~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
output_prob <- predict(rf_default, test_x, "prob")
colnames(output_prob) <- c("odd1", "oddX", "odd2")
output_prob$winner <- test_features$winner
output_prob <- as.data.table(output_prob)[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
testRPS <- lastrps[matchId %in% test_match_ids][, .(var = mean(Shin_RPS, na.rm = TRUE)), by = c("bookmaker")]
testRPS <- testRPS[order(testRPS$var),]
ourRPS <- mean(output_prob$RPS)
x <- data.frame("***IE 492***", ourRPS)
names(x) <- names(testRPS)
testRPS <- rbind(testRPS, x)
testRPS <- testRPS[order(testRPS$var),]
print(testRPS)
}
train_features[,-c("matchId", "date",
asd
fasf)
train_model(48, "2018-2019")
train_model(45, "2018-2019")
train_model(48, "2018-2019")
train_model <- function(weekNumber, seasonYear){
test_match_ids <- matches[week == weekNumber][season == seasonYear]$matchId
test_data <- last[matchId %in% test_match_ids]
wide_test <- widening(test_data[,-4], bookiesToKeep)
test_features <- wide_test
min_date <- min(matches[matchId %in% test_match_ids]$date)
train_features <- wide_last[date < min_date]
train <- train_features[,-c("matchId", "date", "week", "season")]
#train$winner <- factor(convert(train$winner))
train <- train[complete.cases(train)]
test_x <- test_features[,-c("matchId", "winner", "date", "week", "season")]
control <- trainControl(method="repeatedcv", number=10, repeats=3, search = "random")
seed <- 7
metric <- "Accuracy"
set.seed(seed)
mtry <- sqrt(ncol(train))
tunegrid <- expand.grid(.mtry=mtry)
rf_default <- train(factor(convert(winner))~., data=train, method="rf", metric=metric, tuneGrid=tunegrid, trControl=control)
output_prob <- predict(rf_default, test_x, "prob")
colnames(output_prob) <- c("odd1", "oddX", "odd2")
output_prob$winner <- test_features$winner
output_prob <- as.data.table(output_prob)[, RPS := calculate_rps(odd1, oddX, odd2, winner), by = 1:nrow(output_prob)]
testRPS <- lastrps[matchId %in% test_match_ids][, .(var = mean(Shin_RPS, na.rm = TRUE)), by = c("bookmaker")]
testRPS <- testRPS[order(testRPS$var),]
ourRPS <- mean(output_prob$RPS)
x <- data.frame("***IE 492***", ourRPS)
names(x) <- names(testRPS)
testRPS <- rbind(testRPS, x)
testRPS <- testRPS[order(testRPS$var),]
print(testRPS)
}
train_model(48, "2018-2019")
